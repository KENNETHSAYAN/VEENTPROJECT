// src/collections/Transactions.ts
import type { CollectionConfig } from 'payload';
// import { isAdmin } from '../access/isAdmin';
// Access requires checking if user is admin OR if user is linked to the transaction's organizer
// import { isAdminOrLinkedOrganizer } from '../access/isAdminOrLinkedOrganizer';
import type { User } from '../payload-types';

const Transactions: CollectionConfig = {
  slug: 'transactions',
  admin: {
    // Use ID or maybe a generated description? ID is simplest default.
    useAsTitle: 'id',
    description: 'Financial ledger recording all monetary transactions per organizer.',
    defaultColumns: ['transactionDate', 'organizer', 'type', 'amount', 'currency', 'relatedOrder', 'createdAt'],
    listSearchableFields: ['relatedOrder.id', 'relatedPaymentIntentId', 'description'], // Search by related IDs/memo
    group: 'Finance & Reporting',
    // --- CRITICAL: Prevent accidental modification in Admin UI ---
    // Transactions should be immutable records generated by system processes.
    // disableCreation: true,
    // disableUpdate: true,
    // disableDelete: true, // Or allow only specific admin delete with caution
    // Add filters for common reports
    // filters: {
    //     type: {
    //         label: 'Transaction Type',
    //         options: [ /* mirror options below */ ]
    //     },
    //     // Add date range filters, organizer filters if needed by admins
    // },
  },
  // Access Control Notes:
  // VERY restricted. Admins see all. Organizers should ONLY see their own transactions.
  // No one should typically create/update/delete via API directly.
  access: {
    // read: isAdminOrLinkedOrganizer('organizer'), // Custom function: isAdmin or user manages linked organizer
    // create: isAdmin, // Only system processes (running as admin/trusted) should create transactions
    // update: () => false, // Prevent updates
    // delete: isAdmin, // Allow only admins to delete, if ever necessary
    read: () => true,
    create: () => true,
    update: () => true,
    delete: () => true,
  },
  fields: [
    // --- Core Transaction Details ---
    {
      name: 'organizer',
      label: 'Organizer Account',
      type: 'relationship',
      relationTo: 'organizers',
      required: true,
      index: true, // Essential for filtering transactions per organizer
      admin: { readOnly: true, position: 'sidebar' },
    },
    {
      name: 'transactionDate',
      label: 'Transaction Date',
      type: 'date',
      required: true,
      index: true,
      admin: {
        readOnly: true, // Set programmatically
        date: { pickerAppearance: 'dayAndTime' },
        position: 'sidebar',
      },
    },
    {
      name: 'type',
      label: 'Transaction Type',
      type: 'select',
      enumName: 'TransactionType',
      required: true,
      index: true,
      options: [
        { label: 'Ticket Sale', value: 'ticket_sale' }, // Income for organizer
        { label: 'Donation', value: 'donation' },       // Income for organizer
        { label: 'Sale Refund', value: 'refund_sale' }, // Expense for organizer
        { label: 'Donation Refund', value: 'refund_donation' }, // Expense for organizer
        { label: 'Platform Fee', value: 'platform_fee' },   // Expense for organizer (your platform's cut)
        { label: 'Payment Processor Fee', value: 'payment_fee' },// Expense for organizer (e.g., Stripe fee)
        { label: 'Organizer Payout', value: 'payout' },      // Expense for organizer (money sent to them)
        { label: 'Payout Fee', value: 'payout_fee' },      // Expense for organizer (cost of sending payout)
        { label: 'Adjustment Credit', value: 'adj_credit' }, // Manual admin adjustment (+)
        { label: 'Adjustment Debit', value: 'adj_debit' },  // Manual admin adjustment (-)
      ],
      admin: { width: '50%' },
    },
    // --- Financial Value ---
    {
      name: 'amount',
      label: 'Amount',
      type: 'number',
      required: true,
      admin: {
        width: '50%',
        step: 0.01,
        description: 'Value of the transaction. Positive for income (sales, donations), Negative for expenses (refunds, fees, payouts).',
      },
    },
    {
      name: 'currency',
      label: 'Currency',
      type: 'text', // Store as text (e.g., 'USD', 'PHP') - ensure consistency
      required: true,
      admin: { width: '30%' },
    },
    // --- Context & References ---
    {
      name: 'description',
      label: 'Description / Memo',
      type: 'text',
      required: true, // Ensure a clear description exists
      admin: {
        description: 'Brief description (e.g., "Sale for Order #123", "Stripe Fee for ch_xyz")',
      },
    },
    {
      name: 'relatedOrder',
      label: 'Related Order',
      type: 'relationship',
      relationTo: 'orders',
      index: true,
      hasMany: false, // One transaction entry per relevant order event (sale, refund)
      admin: { readOnly: true },
    },
    // Optional link to the user involved (e.g., the buyer for a sale/refund)
    {
      name: 'relatedUser',
      label: 'Related User',
      type: 'relationship',
      relationTo: 'users',
      index: true,
      hasMany: false,
      admin: { readOnly: true },
    },
    {
      name: 'relatedPaymentIntentId',
      label: 'Payment Gateway Ref ID',
      type: 'text',
      index: true,
      admin: { readOnly: true },
    },
    // Optional field for storing raw gateway fee breakdowns, etc.
    {
      name: 'metadata',
      label: 'Additional Metadata',
      type: 'json',
      admin: { readOnly: true },
    },
  ],
  timestamps: true, // Capture when the log entry was created
  hooks: {
    // Hook to ensure transactionDate is set on creation
    beforeChange: [
      ({ data, operation }) => {
        if (operation === 'create' && !data.transactionDate) {
          data.transactionDate = new Date().toISOString();
        }
        // Potentially auto-generate description based on type/related docs?
        // if (operation === 'create' && !data.description && data.type === 'ticket_sale' && data.relatedOrder) {
        //    data.description = `Ticket Sale for Order ${data.relatedOrder}`; // Needs fetching order ID if only relation is passed initially
        // }
        return data;
      }
    ],
    // IMPORTANT: Most transaction entries should be created programmatically
    // in response to other events (e.g., Order status changing to 'paid',
    // payment gateway webhook confirming a charge/refund, payout script execution).
    // Do NOT rely on manual creation via Admin UI or direct API calls from untrusted sources.
  }
};

export default Transactions;


// --- Example isAdminOrLinkedOrganizer Access Control ---
// NOTE: Needs proper implementation using payload.findByID inside access control
// import { Access } from 'payload/types';
// import { User, Organizer } from '../payload-types';
// export const isAdminOrLinkedOrganizer = (organizerField: string = 'organizer'): Access<any, User> =>
//    async ({ req: { user, payload }, id: docId }) => {
//   if (!user) return false;
//   if (user.roles?.includes('admin')) return true;

//   // Check if user manages the organizer linked to this transaction
//   // For list view (no docId): constrain the query
//   if (!docId) {
//       // Find organizers managed by the current user
//       const managedOrganizers = await payload.find({
//            collection: 'organizers',
//            where: { managingUsers: { contains: user.id } },
//            depth: 0, // Only need IDs
//            overrideAccess: true, // Bypass organizer access control for this lookup
//            user, // Pass user for potential internal checks
//       });
//       const managedOrganizerIds = managedOrganizers.docs.map(doc => doc.id);
//       if (managedOrganizerIds.length === 0) return false; // User manages no organizers
//       // Return query constraint: transaction's organizer must be one they manage
//       return { [organizerField]: { in: managedOrganizerIds } };
//   } else {
//       // For single doc read (docId exists): fetch the transaction, then its organizer, then check managingUsers
//       // Placeholder: return false; // Replace with actual fetch and check logic
//       try {
//          const transaction = await payload.findByID({ collection: 'transactions', id: docId, depth: 1, overrideAccess: true, user });
//          const linkedOrganizerId = typeof transaction.organizer === 'string' ? transaction.organizer : transaction.organizer?.id;
//          if (!linkedOrganizerId) return false;
//          // Check if user is in managingUsers of the linked organizer (needs another fetch or smarter query)
//          // This part requires careful implementation to avoid performance issues.
//          // Example simplified check (assumes managingUsers is populated, which might not be efficient):
//          // const organizer = typeof transaction.organizer === 'object' ? transaction.organizer : null;
//          // return organizer?.managingUsers?.some(manager => (typeof manager === 'string' ? manager : manager.id) === user.id);
//          return true; // Replace with real logic
//       } catch (e) {
//           return false;
//       }
//   }
// };